/**
 * File:	modules/SleposUtils.ycp
 * Package:	yast2-slepos-common
 * Summary:	Novell Linux Point of Service utility routines
 * Authors:	Michael G Fritch <mgfritch@novell.com>
 *
 * $Id: SleposUtils.ycp,v 1.28 2005/10/14 03:32:21 mgfritch Exp $
 *
 */

{

module "SleposUtils";

// FIXME: slepos-image-builder depends on this module, if not moved to
// any of the base YaST packages, we must consider either a new dependency
// or move of this file to a new package
textdomain "slepos-common"; // FIXME adapt according to where
			    // it finally resides

import "Popup";
import "Report";
import "Mode";
import "Require";
import "Label";
import "Address";
import "IP";
//import "NetworkDevices";
import "Map";

/**
 * Displays a formatted popup error message, with a details button.
 * @param errorMessage string - a simple message describing the error
 * @param out map - output of the executed command
 * @param cmd string - the executed command
 * @return void
 */
global void errorLogging (string errorMessage, map out, string cmd) ``{
	string message = _("Undefined Error");
	if (errorMessage != nil && errorMessage != "") message = errorMessage;
	Popup::ClearFeedback();
	if (!Popup::AnyQuestion( Label::ErrorMsg(), message, Label::OKButton(), _("Details"), `focus )) {
		string description = sformat("<pre>command: %1 return \n %2 %3</pre>", cmd, out["stderr"]:"", out["stdout"]:"");
		UI::OpenDialog (`opt(`decorated ),
			`HBox( `VSpacing(16),
				`VBox (
					`HSpacing (100),
					// popup window header
					`Heading (message),
					`VSpacing (0.5),
					`RichText (description),
					`VSpacing (1.0),
					// push button label
					`PushButton (`id(`ok), `opt(`default, `key_F10), Label::OKButton())
				)
			)
		);

		UI::SetFocus (`id(`ok));
		UI::UserInput ();
		UI::CloseDialog ();
	}
}



/**
 * Strip leading "stripChars"
 * @param string to modify, string chars to strip
 * @return string
 */
global string StripLeading( string str, string stripChars ) {
	while (size(str) > 1) {
		string check = substring(str, 0, 1);
		if (findfirstof( stripChars, check ) != nil) str = substring(str, 1);
		else break;
	}
	return str;
}



/**
 * Strip trailing "stripChars"
 * @param string to modify, string chars to strip
 * @return string
 */
global string StripTrailing( string str, string stripChars ) {
	while (size(str) > 1) {
		string check = substring(str, size(str)-1, 1);
		if (findfirstof( stripChars, check ) != nil) str = substring(str, 0, size(str)-1);
		else break;
	}
	return str;
}


/**
 * Strip leading and trailing "stripChars"
 * @param string to modify, string chars to strip
 * @return string
 */
global string Strip( string str, string stripChars ) {
	str = StripLeading( str, stripChars );
	str = StripTrailing( str, stripChars );
	return str;
}


/**
 * Replace the substring "replace" with the string "replacement" throughout
 * the input string text
 * @param string text, string replace, string replacement
 * @return string
 */
global string ReplaceSubString(string text, string replace, string replacement) {
	if (text == nil || replace == nil || replace == "" || replacement == nil) return nil;
	if (replace == replacement) return text;

	string reg_expr1 = sformat("(.*)%1(.*)", replace);
	string reg_expr2 = sformat("\\1%1\\2", replacement);
	while (regexpmatch(text, replace))
		text = regexpsub(text, reg_expr1, reg_expr2);
	return text;
}

/**
 * Clean up a string - remove \n, \r, and spaces.
 * @param string
 * @return string
 */
global string CleanUpString(string str) {
	if( str == nil || str == "" ) return str;

	string workStr = Strip(str, " \n\t\r");

	// Since the strip command above does not seem to remove LF chars...
	integer idx = find( workStr, "\n");
	if (idx >= 0) workStr = substring(workStr, 0, idx);

	return workStr;
}


/**
 * Checks if the string is in LDAP form
 * @param string
 * @return boolean
 */
global boolean isLDAP(string ldap) {
	integer index = find (ldap, ",");
	if (index >= 0) return true;
	return false;
}


/**
 * Checks if the string is in NDS (NDAP typed) form
 * @param string
 * @return boolean
 */
global boolean isNDS(string nds) {
	integer index = find (nds, ",");
	if (index >= 0) return false;
	return true;
}


/**
 * Nds2Ldap(string) Convert string from NDS syntax to LDAP syntax
 * MUST take special care to deal with escaped periods "\\."
 * LDAP accepts plain periods.
 * @param string
 * @return string
 */
global string Nds2Ldap(string nds) {
	if (isNDS(nds)) {
		nds = ReplaceSubString(nds, "\\.", "*");
		nds = ReplaceSubString(nds, ",", "&");
		list<string> s = splitstring(nds, ".");
		nds = mergestring(s, ",");
		nds = ReplaceSubString(nds, "*", ".");
		nds = ReplaceSubString(nds, "&", "\\,");
	}
	return nds;
}


/**
 * Ldap2Nds(string) Convert string from LDAP syntax to NDS syntax
 * The "." must become "\\."
 * @param string
 * @return string
 */
global string Ldap2Nds(string ldap) {
	if (isLDAP(ldap)) {
		ldap = ReplaceSubString(ldap, ".", "*");
		ldap = ReplaceSubString(ldap,"\\,", "&");
		list<string> s = splitstring(ldap, ",");
		ldap = mergestring(s, ".");
		ldap = ReplaceSubString(ldap, "*", "\\.");
		ldap = ReplaceSubString(ldap,"&", ",");
	}
	return ldap;
}


/**
 * Typeful2Typeless (string ndsName)
 *
 * Convest an X500 name in NDS format
 * to a typeless version
 * @param string nds name
 * @return string
 */
global string Typeful2Typeless(string ndsName) {
	ndsName = Ldap2Nds(ndsName);
	string tmp = ndsName;
	if (find(tmp, "=") == nil) return tmp;
	tmp = ReplaceSubString(tmp, "\\.", "+");
	list<string> stmp = splitstring(tmp, ".");
	string rval = "";
	foreach( string seg,  stmp, {
		integer idx = find(seg, "=");
		if (idx >= 0) {
			if (rval != "") rval = rval + ".";
			rval = rval + substring(seg,idx+1);
		}
	});
	rval = ReplaceSubString(rval,"+","\\.");
	return rval;
}


/**
 * Return the context containing the name given
 * In NDAP strings we must hadle "\."
 * @param string nds name
 * @return string nds context
 */
global string GetContextNDS( string name ) {
	string tmp = ReplaceSubString(name, "\\.", "*");
	if (tmp!="" && findfirstof(tmp, ".")!=nil) {
		tmp = substring(tmp, findfirstof(tmp, ".") + 1);
		tmp = ReplaceSubString(tmp, "*", "\\.");
		return tmp;
	}
	return "";
}


/**
 * Return the context containing the name given in LDAP
 * There are no "\\." in legal LDAP names
 * @param string ldap name
 * @return string ldap context
 */
global string GetContextLDAP( string name ) {
	string tmp = ReplaceSubString(name, "\\,","*");
	if (tmp!="" && findfirstof(tmp, ",")!=nil) {
		tmp = substring(tmp, findfirstof(tmp, ",") + 1);
		tmp = ReplaceSubString(tmp, "*", "\\,");
		return tmp;
	}
	return "";
}


/**
 * Return the top context for a NDS name
 * @param string nds name
 * @param string nds context
 */
global string GetTopContextNDS( string name ) {
	string topContext = GetContextNDS( name );
	string prevContext = name;
	while( topContext !="" ) {
		prevContext = topContext;
		topContext = GetContextNDS( topContext );
	}
	return prevContext;
}


/**
 * Return the context containing the name given
 * @param string
 * @return string
 */
global string GetContext(string name) {
	if (isLDAP(name)) name = GetContextLDAP(name);
	else name = GetContextNDS(name);
	return name;
}


/**
 * Returns a list contining the CN and context seperated from the FDN (e.g. "cn=admin,o=novell" --> $["admin", "novell"])
 * @param string fdn
 * @return list
 */
global list ExtractCN(string fdn) {
	fdn = Nds2Ldap(fdn);
	integer i = find(fdn, ",");
	
	if (i < 4) return []; //extractCN failed return empty list
	
	string cn = substring(fdn, 3, i-3); //skip over 'cn='
	string context = substring(fdn, i+1);
	return [cn, context];
}


/**
 * Checks if needed packages are installed
 * if not, install the needed packages
 * @param string product name, list<string> rpm names
 * @return boolean
 */
global boolean rpmsInstalled(string product_name, list<string> rpm_list) {
/*
// FIXME: cannot build the following code on a SuSE 9.3 box.... :-(
//	if (!Mode::test) {  // This is the correct code for SLES9
	if (!Mode::test()) {  // This is the correct code for SLES10
*/
		/* ensure edirectory package is installed */
		if( !Require::RequireAndConflictTarget( rpm_list, [],
			// notification about package needed 1/2
			_("<p>To configure ") + product_name + _(", the <b>%1</b> package must be installed.</p>") +
			// notification about package needed 2/2
			_("<p>Do you want to install it now?</p>") ))
		{
			// translators: error popup before aborting the module
			y2error("Required %1 rpms are NOT installed!", rpm_list);
			Popup::Error(_("YaST2 cannot continue the configuration without installing the required packages."));
			return false;
		}
//	}
	y2milestone("Required %1 rpms are installed", product_name);
	return true;
}


/**
 * Will check if a specified RPM is installed
 * @param string rpm name
 * @return true if package is installed, false otherwise
 */
global boolean isRPMInstalled(string rpmname) {
	string cmd = sformat("rpm -qa %1", rpmname);
	integer ret = (integer)SCR::Execute(.target.bash, cmd);
	if ( ret != 0 ) {
		y2debug("RPM not installed: %1", rpmname);
		return false;
	}
	return true;
}


/**
 * See if the specified product was installed during phase 1 of the install.  This is how we determine if a product
 * should show up in the proposal screen.  The input parameter "selection_name" should match the name of the selection
 * file for which information is required (e.g. novell-imanager, novell-ifolder2, X11, Linux_tools, etc.). The
 * parameter "selection_name" is not case sensitive.
 * @param string selection file name
 * @return boolean true on success
 */
global boolean IsSelectionInstalled(string selection_name) {
	if( selection_name == nil || selection_name == "" ) {
		y2milestone("SleposUtils.IsSelectionInstalled:returned false due to empty input parameter.");
		return false;
	}
	
	// toupper this because we are not case sensitive.
	string sel_name = toupper(selection_name);
	sel_name = CleanUpString( sel_name );
	y2milestone("SleposUtils.IsSelectionInstalled:selection_name: %1", sel_name);
	
	// Get the list of selections that were installed during phase 1 of the install.
	list<string> installed_selections = Pkg::GetSelections (`installed, "");
	y2debug ("SleposUtils:installed selections are %1", installed_selections);
	
	integer idx = -1;
	boolean found = false;
	
	// See if selection_name matches any of the module names returned.
	foreach (string sel, installed_selections, {
		sel = CleanUpString( sel );
		// bugzilla 98532
		//      idx = find( toupper(sel), sel_name );
		//      if( idx  >= 0 )
		if( toupper(sel) == sel_name ) {
			found = true;
			break;
		}
	});
	
	y2milestone("SleposUtils.IsSelectionInstalled: %1 : %2", selection_name, found);
	return found;
}


/**
 * Get contents of environment variable.
 * @param environment name of requested variable
 * @return environment variable contents
 */
global string getenv(string environment) {
	string command = sformat("echo $%1", environment);
	map result = (map) SCR::Execute(.target.bash_output, command, []);
	// Adding a line feed to the test to catch an empty env parm.
	if(result["stdout"]:"" == "\n" || result["stdout"]:"" == "") {
		y2milestone("The eviornment variable %1 is undefined", environment);
		return nil;
	}
	else {
		string value = (string) result["stdout"]:"";
		y2milestone("The eviornment variable %1 = %2",environment, value);
		return value;
	}
}


/**
 * See if eDirectory is currently running.
 * @return boolean
 */
global boolean IseDirRunning() {
	boolean running = false;
	
	string cmd = "ps -ef | grep ndsd | grep -v grep | wc -l | tr -d \"\\n\"";
	map ret = (map) SCR::Execute(.target.bash_output, cmd);
	if (ret["exit"]:-1 == 0) {
		string output = (string)ret["stdout"]:"-1";
		if (tointeger(output) > 0) running = true; // eDirectory is RUNNING
	}
	return running;
}


/**
 * See if eDirectory is installed locally on this machine and is running.
 * @return boolean
 */
global boolean IsEdirectoryInstalledLocally() {
	return IseDirRunning();
}



/**
 * Return the hostname of the local machine
 * @return string host name
 */
global string GetHostname() {
	map rmap = (map)SCR::Execute(.target.bash_output, "hostname");
	if (rmap["exit"]:-1 == 0) {
		string hostname = rmap["stdout"]:"";
		hostname = Strip(hostname, " \n\t\r");
	
		// Since the strip command above does not seem to remove LF chars...
		integer idx = find( hostname, "\n");
		if (idx >= 0) hostname = substring(hostname,0,idx);
	
		return hostname;
	}
	else return "";
}


/**
 * Return the domain name of the local machine
 * @return string Domain name
 */
global string GetDomainname() {
	map rmap = (map)SCR::Execute(.target.bash_output, "hostname -d");
	if (rmap["exit"]:-1 == 0) {
		string hostname = rmap["stdout"]:"";
		hostname = Strip(hostname, " \n\t\r");
	
		// Since the strip command above does not seem to remove LF chars...
		integer idx = find( hostname, "\n");
		if (idx >= 0) hostname = substring(hostname,0,idx);
	
		return hostname;
	}
	else return "";
}


/**
 * Return the DNS name of the local machine
 * It seems that this is the DNS name of eth0
 * in the case of multiple NICs.
 * @return string DNS name
 */
global string GetDNSname() {
	map rmap = (map)SCR::Execute(.target.bash_output, "hostname -f");
	if (rmap["exit"]:-1 == 0) {
		string hostname = rmap["stdout"]:"";
		hostname = Strip(hostname, " \n\t\r");
	
		// Since the strip command above does not seem to remove LF chars...
		integer idx = find( hostname, "\n");
		if (idx >= 0) hostname = substring(hostname,0,idx);
	
		return hostname;
	}
	else return "";
}


/**
 * Use the host command and parse its' output to get the DNS name
 * that corresponds to the IP address
 * @param string ip address
 * @return string dns name
 */
global string GetDNSNameForIPAddress(string ipAddress) {
	if (ipAddress == "") return "";
	string cmd = "host -W 15 " + ipAddress + " | sed -e \"s/^.*pointer //\" | sed -e \"s/.$//\" | tr -d \"\\n\"";
	y2milestone("About to execute host command (using UDP)%1", cmd);
	map rmap = (map) SCR::Execute(.target.bash_output, cmd);
	if (rmap["exit"]:-1 == 0) {
		string name = rmap["stdout"]:"";
		if (find( name, ";;" ) != -1 || find(name, "3(NXDOMAIN") != -1 || find(name, "2(SERVFAIL") != -1 || find(name, "not found") != -1) {
			// try TCP
			string cmd = "host -TW 15 " + ipAddress + " | sed -e \"s/^.*pointer //\" | sed -e \"s/.$//\" | tr -d \"\\n\"";
			y2milestone("About to execute host command (using TCP) %1", cmd);
			if (rmap["exit"]:-1 == 0) {
				if (find( name, ";;" ) != -1 || find(name, "3(NXDOMAIN") != -1 || find(name, "2(SERVFAIL") != -1 || find(name, "not found") !=  -1) {
					// Failed to get a valid value
					return "";
				}
				else {
					//found using TCP
					return name;
				}
			}
			else return ""; // Command had non-zero exit status
		}
		//found using UDP
		return name;
	}
	else return ""; // Command had non-zero exit status
}



/**
 * GetIPAddressForDNSName(string dnsName)
 *
 * Use the host command and parse its' output to get the IPAddress
 * that corresponds to the given DNSName
 *
 * @param string dns name
 * @return string ip address
 */
global string GetIPAddressForDNSName(string dnsName) {
	if (dnsName == "") return "";

	// A DNS name can translate to MULTIPLE IP addresses
	// Also "host" can return lines which say that foobar.com is an alias
	// for www.foobar.com so we remove those lines and take the first one that
	// follows
	string cmd = "host -W 15 " + dnsName + " | sed -e \"s/^.*address //\" | sed -e \"/alias/d\" | sed -e \"1q\" |  tr -d \"\n\"";
	y2milestone("About to execute command %1", cmd);
	map rmap = (map) SCR::Execute(.target.bash_output, cmd);
	if (rmap["exit"]:-1 == 0) return rmap["stdout"]:"";
	else return "";
}


/**
 * Return the IP address of the local machine's eth0 interface
 * @return string ip address
 */
global string GetIPAddrEth0() {
	list<map> ifconfig =(list<map>)SCR::Read(.run.ifconfig);
	ifconfig = filter(map iface, ifconfig, ``( iface["name"]:"" == "eth0"));
	integer ip = ifconfig[0,"value", "inet", "addr"]:0;
	return (IP::ToString(ip));
}


/**
 *  Returns a map of all network interfaces with
 *  static IP addresses
 *
 *  The returned map is structued as follows:
 *
 *  $[IP_Address:Hardware_Address]
 *
 * @return map
 */
/*map GetAllStaticInterfaces() {
//FIXME: For some unknown reason autobuild dies when trying to import the NetworkDevices module????
	//read current settings for network
	NetworkDevices::Read();

	//generate the map: static IP -> device
	map ip2device = $[];
	list<string>devs=NetworkDevices::Locate("BOOTPROTO","static");
	foreach(string dev, devs, {
		string ip=NetworkDevices::GetValue(dev,"IPADDR");
		if(ip!=nil && ip != "")ip2device[ip]=dev;
	});
	
	y2debug("Mapping of IP addresses and network devices: %1",ip2device);
	return ip2device;
}*/

/**
 * The original method is found above (GetIPAddrEth0)
 * It was insufficient as it only returned the IP address
 * associated with eth0
 *
 * This updated function gets the IP address of the 1st
 * interface with a static address
 *
 * If there are no such addresses then return empty string
 *
 * @return string ip address
 */
/*global string GetIPAddr() {
//FIXME: For some unknown reason autobuild dies when trying to import the NetworkDevices module????
	string ip = "";
	map staticInterfaces = GetAllStaticInterfaces();
	
	list addrList = Map::Keys(staticInterfaces);
	integer count = size(addrList);
	integer i=0;
	while (i < count) {
		ip = (string) addrList[0]:"";
		if (ip != "") {
			// We use Address here rather than calling
			// NovellValidators to avoid cyclic dependency
			// between NovellUtils and NovellValidators
			if (Address::Check4(ip)) {
				y2debug("First static IP address %1", ip);
				return ip;
			}
		}
		i=i+1;
	}
	y2milestone("First static IP address %1", ip);
	return "";
}*/


/**
 * Returns a list of all static IP addresses found on the system
 * @return list
 */
/*global list GetAllStaticIPAddrs() {
//FIXME: For some unknown reason autobuild dies when trying to import the NetworkDevices module????
	map staticInterfaces = GetAllStaticInterfaces();
	list addrList = Map::Keys(staticInterfaces);
	return addrList;
}
*/

/**
 * Given an IP address return the device to which
 * the address is bound
 * @param string ip address
 * @return string device
 */
global string MapIPAddrToDevice(string ip) {
	string cmd = sformat("ip -family inet -oneline addr show to %1 | cut -d \" \" -f2", ip);
	map ret = (map) SCR::Execute(.target.bash_output, cmd);
	if (ret["exit"]:-1 == 0) {
		string device = ret["stdout"]:"";
		device = Strip(device, " \t\n");
		y2milestone("The ip address %1 mapped to the device \"%2\"", ip, device);
		return device;
	}
	else return "";
}

/**
 * Returns the current date in ISO 8601 format (YYYY-MM-DD)
 * @return string iso 8601 date
 */
global string GetDateIso8601() {
	string cmd = "date --iso-8601"; // retrive the build date.
	map ret = (map) SCR::Execute(.target.bash_output, cmd);
	if (ret["exit"]:-1 == 0) return CleanUpString(ret["stdout"]:"");
	return nil;
}


/* EOF */
}
